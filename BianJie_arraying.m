function [data1,tu3] = BianJie_arraying(tu2)
% 输入边界图像的01矩阵contour，输出搜索出来的边界图像有序点集data,tu3是做调试用的参数实际不需要

%**************思想**************%
% 原理是每一个点如果在它的上下左右方向上有其他点，那这个点必然是挨着它的下一个点，如果没有，那必然能找到右上、右下、左下、左上方向上的一个临近点
% 1，从01矩阵中找到第一个点的坐标
% 2，从该点进行搜索，先从上方依上右下左的顺序搜索该点的临近点，找到后记录坐标
% 3，如果四个正方向上没找到，就依右上。右下、左下、左上的顺序搜索临近点并记录坐标
% 4，找到的临近点要与该点的上一个临近点进行对比，如果坐标是同一个点，那么排除，继续搜索
% 5，进行循环，直到01矩阵图像中所有标为1的点全都找到，结束并输出有序点集

tu1 = tu2; % 倒换点集，防止破坏原点集
% 这里借用周长函数，把所有数值为1的点的数目找到，并找到第一个点
zhouchang1=0;
xy=[]; % 这个存储找到的第一个点的坐标值
for i10 = 1:size(tu1,1)
    for j = 1:size(tu1,2)
        if tu1(i10,j)==1 
            zhouchang1 = zhouchang1+1;
            xy = [i10,j]; % 坐标存储进去了
        end
    end
end
% zhouchang1; % 这里是边界周长
% zhouchang1 = zhouchang1; % 测试周长长度
% xy; % 这里是第一个点的坐标值，前面是x坐标，后面是y坐标

% % 边界点检测
% J = zeros(zhouchang1,2);
% jj=1;
% for i = 1:size(contour,1)
%     for j = 1:size(contour,2)
%         if contour(i,j)==1
%             jj = jj+1;
%             J(jj,:) = [i,j]; % 坐标存储进去了
%         end
%     end
% end
% figure,plot(J(:,1),J(:,2),'*');

% %*********!!!
% xy = [3258,2267];
% xy
% %*********!!!

I = zeros(zhouchang1,2); % 存放搜索出来的所有点的集合
I(1,:) = xy; % 直接存储第一个点的坐标值

% 开始搜索
xy000 = [-1,-1];
xy00 = [-1,-1];
xy0 = [-1,-1]; % 初始参考坐标点，后面会使用上一个临近点进行覆盖
xy; % 表示搜索到该点
i=1;
while(i<zhouchang1)
    i = i+1;
        % 搜索上方
        if tu1(xy(1),xy(2)+1)==1
            if ~(xy(1)==xy0(1) && xy(2)+1==xy0(2))
                if ~(xy(1)==xy00(1) && xy(2)+1==xy00(2))
                    if ~(xy(1)==xy000(1) && xy(2)+1==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1),xy(2)+1]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索右方
        if tu1(xy(1)+1,xy(2))==1
            if ~(xy(1)+1==xy0(1) && xy(2)==xy0(2))
                if ~(xy(1)+1==xy00(1) && xy(2)==xy00(2))
                    if ~(xy(1)+1==xy000(1) && xy(2)==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1)+1,xy(2)]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索下方
        if tu1(xy(1),xy(2)-1)==1
            if ~(xy(1)==xy0(1) && xy(2)-1==xy0(2))
                if ~(xy(1)==xy00(1) && xy(2)-1==xy00(2))
                    if ~(xy(1)==xy000(1) && xy(2)-1==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1),xy(2)-1]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索左方
        if tu1(xy(1)-1,xy(2))==1
            if ~(xy(1)-1==xy0(1) && xy(2)==xy0(2))
                if ~(xy(1)-1==xy00(1) && xy(2)==xy00(2))
                    if ~(xy(1)-1==xy000(1) && xy(2)==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1)-1,xy(2)]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索右上
        if tu1(xy(1)+1,xy(2)+1)==1
            if ~(xy(1)+1==xy0(1) && xy(2)+1==xy0(2))
                if ~(xy(1)+1==xy00(1) && xy(2)+1==xy00(2))
                    if ~(xy(1)+1==xy000(1) && xy(2)+1==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1)+1,xy(2)+1]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索右下
        if tu1(xy(1)+1,xy(2)-1)==1
            if ~(xy(1)+1==xy0(1) && xy(2)-1==xy0(2))
                if ~(xy(1)+1==xy00(1) && xy(2)-1==xy00(2))
                    if ~(xy(1)+1==xy000(1) && xy(2)-1==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1)+1,xy(2)-1]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索左下
        if tu1(xy(1)-1,xy(2)-1)==1
            if ~(xy(1)-1==xy0(1) && xy(2)-1==xy0(2))
                if ~(xy(1)-1==xy00(1) && xy(2)-1==xy00(2))
                    if ~(xy(1)-1==xy000(1) && xy(2)-1==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1)-1,xy(2)-1]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
        % 搜索左上
        if tu1(xy(1)-1,xy(2)+1)==1
            if ~(xy(1)-1==xy0(1) && xy(2)+1==xy0(2))
                if ~(xy(1)-1==xy00(1) && xy(2)+1==xy00(2))
                    if ~(xy(1)-1==xy000(1) && xy(2)+1==xy000(2))
                        xy000 = xy00;
                        xy00 = xy0;
                xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
                xy = [xy(1)-1,xy(2)+1]; % 下一个点变成需要搜索的该点
                I(i,:) = xy; % 把搜索到的点存储
                continue;
                    end
                end
            end
        end
%         disp('未搜索到数据');
end

% % 开始搜索&改
% % %***********!!!
% % xy0 = []
% % %***********!!!
% xy0 = [xy(1),xy(2)-1]; % 初始参考坐标点，后面会使用上一个临近点进行覆盖
% % xy0
% xy00 = [xy(1)-1,xy(2)-1]; % 表示再往上的一个点
% xyy = xy; % 表示永远不变的原始点记录
% % xy % 表示搜索到该点
% contour1(xy(1),xy(2)-1) = 2; % 把点集的已搜索点标记为2，防止下次再次搜索到该点
% contour1(xy(1),xy(2)) = 2; % 把点集的已搜索点标记为2，防止下次再次搜索到该点
% jj=1;
% while(jj<zhouchang1)
%     jj = jj+1;
% %     jj
%     % 初始化，生成八方向点信息列表
%     K = zeros(8,3);
%     K(1,:) = [xy(1)-1,xy(2)-1,contour1(xy(1)-1,xy(2)-1)];
%     K(2,:) = [xy(1)-1,xy(2),contour1(xy(1)-1,xy(2))];
%     K(3,:) = [xy(1)-1,xy(2)+1,contour1(xy(1)-1,xy(2)+1)];
%     K(4,:) = [xy(1),xy(2)+1,contour1(xy(1),xy(2)+1)];
%     K(5,:) = [xy(1)+1,xy(2)+1,contour1(xy(1)+1,xy(2)+1)];
%     K(6,:) = [xy(1)+1,xy(2),contour1(xy(1)+1,xy(2))];
%     K(7,:) = [xy(1)+1,xy(2)-1,contour1(xy(1)+1,xy(2)-1)];
%     K(8,:) = [xy(1),xy(2)-1,contour1(xy(1),xy(2)-1)];
% %     K
%     % 搜索方法存在bug
% %     for i10 = 1:8
% %         if (K(i10,1)==xy0(1) && K(i10,2)==xy0(2))
% %             k10=i10; % 记录上一个点的序号
% %         end
% %     end
% %     k10
% %     for i10 = 1:8
% %         k10 = k10+1; % 从上一个点的行序号开始搜索
% %         if k10>8
% %             k10 = k10-8; % 防一手序号溢出
% %         end
% %         k10
% %         K(k10,3)
% %         if K(k10,3)==1
% %             xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
% %             xy0
% %             xy = [K(k10,1),K(k10,2)]; % 下一个点变成需要搜索的该点
% %             xy
% %             I(jj,:) = xy;
% % %             I(jj,:)
% %             break;
% %         end
% %     end
%     
%     % 搜索方法&改
%     for i10 = 1:8 % 搜索上一个点对应列表的行序号
%         if (K(i10,1)==xy0(1) && K(i10,2)==xy0(2))
%             k10=i10; % 记录上一个点的序号
%         end
%     end
% %     k10
%     % 序号检测
%     a = k10; % 检测正方向时用k10
%     n10 = k10; % 检测偏方向时用n10
%     if a==1||a==3||a==5||a==7 % 奇数说明上一个点在偏四方向
%         k10 = k10+1;
%         n10 = n10+2;
%     end
%     if a==2||a==4||a==6||a==8
%         k10 = k10+2;
%         n10 = n10+1;
%     end
%     % 先搜正方向
%     for i=1:4
%         flag=0; % 标志位用于判断是否需要继续检测偏四方向
%         if k10>8
%             k10 = k10-8; % 防一手序号溢出
%         end
% %         k10
% %         K(k10,3)
% %         if K(k10,3)==1 % 防止搜到上次的点
% %             if K(k10,1)==xy0(1)&&K(k10,2)==xy0(2)
% %                 K(k10,:)
% %                 if a==1||a==3||a==5||a==7 % 奇数说明上一个点在偏四方向
% %                     k10 = k10+1;
% %                     n10 = n10+2;
% %                 end
% %                 if a==2||a==4||a==6||a==8
% %                     k10 = k10+2;
% %                     n10 = n10+1;
% %                 end
% %                 break
% %             end
% %         end
%         if K(k10,3)==1
%             if ~(K(k10,1)==xy0(1)&&K(k10,2)==xy0(2))
%                 if ~(K(k10,1)==xy00(1)&&K(k10,2)==xy00(2))
%                     xy00 = xy0; % 上上个点等于上个点
% %                   contour1(K(k10,1),K(k10,2)) = 2; % 把点集的已搜索点标记为2，防止下次再次搜索到该点
%                     xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
% %                   xy0
%                     xy = [K(k10,1),K(k10,2)]; % 下一个点变成需要搜索的该点
% %                   xy
%                     I(jj,:) = xy;
% %                   I(jj,:)
%                     flag = 1; % 说明无需继续搜索偏四方向
%                     break; 
%                 end
%             end
%         end
%         k10 = k10+2;
%     end
%     % 再搜偏四方向
%     for i=1:4
%         if n10>8
%             n10 = n10-8; % 防一手序号溢出
%         end
%         if flag==1 % 说明已经找到了
%             break
%         end
% %         n10
% %         K(n10,3)
%         if K(n10,3)==1
%             if ~(K(n10,1)==xy0(1)&&K(n10,2)==xy0(2))
%                 if ~(K(n10,1)==xy0(1)&&K(n10,2)==xy0(2))
%                     xy00 = xy0; % 上上个点等于上个点
% %                   contour1(K(n10,1),K(n10,2)) = 2; % 把点集的已搜索点标记为2，防止下次再次搜索到该点
%                     xy0 = [xy(1),xy(2)]; % 找到了！该点变成下一个点的上一个临近点
% %                   xy0
%                     xy = [K(n10,1),K(n10,2)]; % 下一个点变成需要搜索的该点
% %                   xy
%                     I(jj,:) = xy;
% %                   I(jj,:)
%                     break;
%                 end
%             end
%         end
%         n10 = n10+2;
%     end
% 
% %     % 接下来如果边界已重合，不再循环
% %     if  (I(jj,1) == xyy(1) && I(jj,2) == xyy(2))
% %         break;
% %     end
% end

data1 = I; % 输出最终结果
tu3 = tu1;

end